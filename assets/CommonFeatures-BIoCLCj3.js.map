{"version":3,"mappings":"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","names":["dialogContainerClassname","dateFormatter","currencyFormatter","Intl","style","SelectColumn","key","name","frozen","renderSummaryCell","renderEditCell","row","width","draggable","country","e","onRowChange","target","value","progress","Math","onClose","createPortal","direction","event","document","body","renderCell","available","tabIndex","yesCount","rowKeyGetter","id","countries","createRows","Date","now","i","rows","push","title","client","area","contact","assignee","startTimestamp","endTimestamp","round","budget","random","account","finance","iban","version","faker","semver","getComparator","sortColumn","localeCompare","a","Error","CommonFeatures","useDirection","selectedRows","gridRef","useRef","columns","useMemo","summaryRows","totalCount","length","filter","sortColumns","toSorted","sort","compResult","comparator","flushSync","setIsExporting","exportToCsv","exportToPdf","toolbarClassname","handleExportToCsv"],"ignoreList":[],"sources":["../../website/utils.tsx","../../website/routes/CommonFeatures.tsx?tsr-split=component"],"sourcesContent":["export function exportToCsv(gridEl: HTMLDivElement, fileName: string) {\n  const { head, body, foot } = getGridContent(gridEl);\n  const content = [...head, ...body, ...foot]\n    .map((cells) => cells.map(serialiseCellValue).join(','))\n    .join('\\n');\n\n  downloadFile(fileName, new Blob([content], { type: 'text/csv;charset=utf-8;' }));\n}\n\nexport async function exportToPdf(gridEl: HTMLDivElement, fileName: string) {\n  const { head, body, foot } = getGridContent(gridEl);\n  const [{ jsPDF }, { default: autoTable }] = await Promise.all([\n    import('jspdf'),\n    import('jspdf-autotable')\n  ]);\n  const doc = new jsPDF({\n    orientation: 'l',\n    unit: 'px'\n  });\n\n  autoTable(doc, {\n    head,\n    body,\n    foot,\n    horizontalPageBreak: true,\n    styles: { cellPadding: 1.5, fontSize: 8, cellWidth: 'wrap' },\n    tableWidth: 'wrap'\n  });\n  doc.save(fileName);\n}\n\nfunction getGridContent(gridEl: HTMLDivElement) {\n  return {\n    head: getRows('.rdg-header-row'),\n    body: getRows('.rdg-row:not(.rdg-summary-row)'),\n    foot: getRows('.rdg-summary-row')\n  };\n\n  function getRows(selector: string) {\n    return Array.from(gridEl.querySelectorAll<HTMLDivElement>(selector)).map((gridRow) => {\n      return Array.from(gridRow.querySelectorAll<HTMLDivElement>('.rdg-cell')).map(\n        (gridCell) => gridCell.innerText\n      );\n    });\n  }\n}\n\nfunction serialiseCellValue(value: unknown) {\n  if (typeof value === 'string') {\n    const formattedValue = value.replace(/\"/g, '\"\"');\n    return formattedValue.includes(',') ? `\"${formattedValue}\"` : formattedValue;\n  }\n  return value;\n}\n\nfunction downloadFile(fileName: string, data: Blob) {\n  const downloadLink = document.createElement('a');\n  downloadLink.download = fileName;\n  const url = URL.createObjectURL(data);\n  downloadLink.href = url;\n  downloadLink.click();\n  URL.revokeObjectURL(url);\n}\n","import { useMemo, useRef, useState } from 'react';\nimport { createPortal, flushSync } from 'react-dom';\nimport { faker } from '@faker-js/faker';\nimport { css } from 'ecij';\n\nimport {\n  DataGrid,\n  renderTextEditor,\n  SelectCellFormatter,\n  SelectColumn,\n  type Column,\n  type DataGridHandle,\n  type Direction,\n  type SortColumn\n} from '../../src';\nimport { textEditorClassname } from '../../src/editors/renderTextEditor';\nimport { exportToCsv, exportToPdf } from '../utils';\nimport { useDirection } from '../directionContext';\n\nexport const Route = createFileRoute({\n  component: CommonFeatures\n});\n\nconst toolbarClassname = css`\n  display: flex;\n  justify-content: flex-end;\n  gap: 8px;\n  margin-block-end: 8px;\n`;\n\nconst dialogContainerClassname = css`\n  position: absolute;\n  inset: 0;\n  display: flex;\n  place-items: center;\n  background: rgba(0, 0, 0, 0.1);\n\n  > dialog {\n    width: 300px;\n    > input {\n      width: 100%;\n    }\n\n    > menu {\n      text-align: end;\n    }\n  }\n`;\n\nconst dateFormatter = new Intl.DateTimeFormat(navigator.language);\nconst currencyFormatter = new Intl.NumberFormat(navigator.language, {\n  style: 'currency',\n  currency: 'eur'\n});\n\ninterface SummaryRow {\n  id: string;\n  totalCount: number;\n  yesCount: number;\n}\n\ninterface Row {\n  id: number;\n  title: string;\n  client: string;\n  area: string;\n  country: string;\n  contact: string;\n  assignee: string;\n  progress: number;\n  startTimestamp: number;\n  endTimestamp: number;\n  budget: number;\n  transaction: string;\n  account: string;\n  version: string;\n  available: boolean;\n}\n\nfunction getColumns(\n  countries: readonly string[],\n  direction: Direction\n): readonly Column<Row, SummaryRow>[] {\n  return [\n    SelectColumn,\n    {\n      key: 'id',\n      name: 'ID',\n      frozen: true,\n      resizable: false,\n      renderSummaryCell() {\n        return <strong>Total</strong>;\n      }\n    },\n    {\n      key: 'title',\n      name: 'Task',\n      frozen: true,\n      renderEditCell: renderTextEditor,\n      renderSummaryCell({ row }) {\n        return `${row.totalCount} records`;\n      }\n    },\n    {\n      key: 'client',\n      name: 'Client',\n      width: 'max-content',\n      draggable: true,\n      renderEditCell: renderTextEditor\n    },\n    {\n      key: 'area',\n      name: 'Area',\n      renderEditCell: renderTextEditor\n    },\n    {\n      key: 'country',\n      name: 'Country',\n      renderEditCell: (p) => (\n        <select\n          autoFocus\n          className={textEditorClassname}\n          value={p.row.country}\n          onChange={(e) => p.onRowChange({ ...p.row, country: e.target.value }, true)}\n        >\n          {countries.map((country) => (\n            <option key={country}>{country}</option>\n          ))}\n        </select>\n      )\n    },\n    {\n      key: 'contact',\n      name: 'Contact',\n      renderEditCell: renderTextEditor\n    },\n    {\n      key: 'assignee',\n      name: 'Assignee',\n      renderEditCell: renderTextEditor\n    },\n    {\n      key: 'progress',\n      name: 'Completion',\n      renderCell(props) {\n        const value = props.row.progress;\n        return (\n          <>\n            <progress max={100} value={value} style={{ inlineSize: 50 }} /> {Math.round(value)}%\n          </>\n        );\n      },\n      renderEditCell({ row, onRowChange, onClose }) {\n        return createPortal(\n          <div\n            dir={direction}\n            className={dialogContainerClassname}\n            onKeyDown={(event) => {\n              if (event.key === 'Escape') {\n                onClose();\n              }\n            }}\n          >\n            <dialog open>\n              <input\n                autoFocus\n                type=\"range\"\n                min=\"0\"\n                max=\"100\"\n                value={row.progress}\n                onChange={(e) => onRowChange({ ...row, progress: e.target.valueAsNumber })}\n              />\n              <menu>\n                <button type=\"button\" onClick={() => onClose()}>\n                  Cancel\n                </button>\n                <button type=\"button\" onClick={() => onClose(true)}>\n                  Save\n                </button>\n              </menu>\n            </dialog>\n          </div>,\n          document.body\n        );\n      },\n      editorOptions: {\n        displayCellContent: true\n      }\n    },\n    {\n      key: 'startTimestamp',\n      name: 'Start date',\n      renderCell(props) {\n        return dateFormatter.format(props.row.startTimestamp);\n      }\n    },\n    {\n      key: 'endTimestamp',\n      name: 'Deadline',\n      renderCell(props) {\n        return dateFormatter.format(props.row.endTimestamp);\n      }\n    },\n    {\n      key: 'budget',\n      name: 'Budget',\n      renderCell(props) {\n        return currencyFormatter.format(props.row.budget);\n      }\n    },\n    {\n      key: 'transaction',\n      name: 'Transaction type'\n    },\n    {\n      key: 'account',\n      name: 'Account'\n    },\n    {\n      key: 'version',\n      name: 'Version',\n      renderEditCell: renderTextEditor\n    },\n    {\n      key: 'available',\n      name: 'Available',\n      renderCell({ row, onRowChange, tabIndex }) {\n        return (\n          <SelectCellFormatter\n            value={row.available}\n            onChange={() => {\n              onRowChange({ ...row, available: !row.available });\n            }}\n            tabIndex={tabIndex}\n          />\n        );\n      },\n      renderSummaryCell({ row: { yesCount, totalCount } }) {\n        return `${Math.floor((100 * yesCount) / totalCount)}% ✔️`;\n      }\n    }\n  ];\n}\n\nfunction rowKeyGetter(row: Row) {\n  return row.id;\n}\n\nlet countries: string[] = [];\n\nfunction createRows(): readonly Row[] {\n  const now = Date.now();\n  const rows: Row[] = [];\n  const countrySet = new Set<string>();\n\n  for (let i = 0; i < 1000; i++) {\n    const country = faker.location.country();\n    countrySet.add(country);\n\n    rows.push({\n      id: i,\n      title: `Task #${i + 1}`,\n      client: faker.company.name(),\n      area: faker.person.jobArea(),\n      country,\n      contact: faker.internet.exampleEmail(),\n      assignee: faker.person.fullName(),\n      progress: Math.random() * 100,\n      startTimestamp: now - Math.round(Math.random() * 1e10),\n      endTimestamp: now + Math.round(Math.random() * 1e10),\n      budget: 500 + Math.random() * 10500,\n      transaction: faker.finance.transactionType(),\n      account: faker.finance.iban(),\n      version: faker.system.semver(),\n      available: Math.random() > 0.5\n    });\n  }\n\n  countries = [...countrySet].sort(new Intl.Collator().compare);\n\n  return rows;\n}\n\ntype Comparator = (a: Row, b: Row) => number;\n\nfunction getComparator(sortColumn: string): Comparator {\n  switch (sortColumn) {\n    case 'assignee':\n    case 'title':\n    case 'client':\n    case 'area':\n    case 'country':\n    case 'contact':\n    case 'transaction':\n    case 'account':\n    case 'version':\n      return (a, b) => {\n        return a[sortColumn].localeCompare(b[sortColumn]);\n      };\n    case 'available':\n      return (a, b) => {\n        return a[sortColumn] === b[sortColumn] ? 0 : a[sortColumn] ? 1 : -1;\n      };\n    case 'id':\n    case 'progress':\n    case 'startTimestamp':\n    case 'endTimestamp':\n    case 'budget':\n      return (a, b) => {\n        return a[sortColumn] - b[sortColumn];\n      };\n    default:\n      throw new Error(`unsupported sortColumn: \"${sortColumn}\"`);\n  }\n}\n\nfunction CommonFeatures() {\n  const direction = useDirection();\n  const [rows, setRows] = useState(createRows);\n  const [sortColumns, setSortColumns] = useState<readonly SortColumn[]>([]);\n  const [selectedRows, setSelectedRows] = useState((): ReadonlySet<number> => new Set());\n  const [isExporting, setIsExporting] = useState(false);\n  const gridRef = useRef<DataGridHandle>(null);\n  const columns = useMemo(() => getColumns(countries, direction), [direction]);\n\n  const summaryRows = useMemo((): readonly SummaryRow[] => {\n    return [\n      {\n        id: 'total_0',\n        totalCount: rows.length,\n        yesCount: rows.filter((r) => r.available).length\n      }\n    ];\n  }, [rows]);\n\n  const sortedRows = useMemo((): readonly Row[] => {\n    if (sortColumns.length === 0) return rows;\n\n    return rows.toSorted((a, b) => {\n      for (const sort of sortColumns) {\n        const comparator = getComparator(sort.columnKey);\n        const compResult = comparator(a, b);\n        if (compResult !== 0) {\n          return sort.direction === 'ASC' ? compResult : -compResult;\n        }\n      }\n      return 0;\n    });\n  }, [rows, sortColumns]);\n\n  function handleExportToCsv() {\n    flushSync(() => {\n      setIsExporting(true);\n    });\n\n    exportToCsv(gridRef.current!.element!, 'CommonFeatures.csv');\n\n    flushSync(() => {\n      setIsExporting(false);\n    });\n  }\n\n  async function handleExportToPdf() {\n    flushSync(() => {\n      setIsExporting(true);\n    });\n\n    await exportToPdf(gridRef.current!.element!, 'CommonFeatures.pdf');\n\n    flushSync(() => {\n      setIsExporting(false);\n    });\n  }\n\n  return (\n    <>\n      <div className={toolbarClassname}>\n        <button type=\"button\" onClick={handleExportToCsv}>\n          Export to CSV\n        </button>\n        <button type=\"button\" onClick={handleExportToPdf}>\n          Export to PDF\n        </button>\n      </div>\n      <DataGrid\n        ref={gridRef}\n        aria-label=\"Common Features Example\"\n        rowKeyGetter={rowKeyGetter}\n        columns={columns}\n        rows={sortedRows}\n        defaultColumnOptions={{\n          sortable: true,\n          resizable: true\n        }}\n        selectedRows={selectedRows}\n        onSelectedRowsChange={setSelectedRows}\n        onRowsChange={setRows}\n        sortColumns={sortColumns}\n        onSortColumnsChange={setSortColumns}\n        topSummaryRows={summaryRows}\n        bottomSummaryRows={summaryRows}\n        className=\"fill-grid\"\n        direction={direction}\n        enableVirtualization={!isExporting}\n      />\n    </>\n  );\n}\n"],"file":"CommonFeatures-BIoCLCj3.js"}