{"version":3,"file":"RowGrouping-H_tIgkCz.js","sources":["../../src/cellRenderers/renderToggleGroup.tsx","../../src/GroupCell.tsx","../../src/GroupRow.tsx","../../src/TreeDataGrid.tsx","../../website/routes/RowGrouping.tsx?tsr-split=component"],"sourcesContent":["import { css } from '@linaria/core';\n\nimport type { RenderGroupCellProps } from '../types';\n\nconst groupCellContent = css`\n  @layer rdg.GroupCellContent {\n    outline: none;\n  }\n`;\n\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\n\nconst caret = css`\n  @layer rdg.GroupCellCaret {\n    margin-inline-start: 4px;\n    stroke: currentColor;\n    stroke-width: 1.5px;\n    fill: transparent;\n    vertical-align: middle;\n\n    > path {\n      transition: d 0.1s;\n    }\n  }\n`;\n\nconst caretClassname = `rdg-caret ${caret}`;\n\nexport function renderToggleGroup<R, SR>(props: RenderGroupCellProps<R, SR>) {\n  return <ToggleGroup {...props} />;\n}\n\nexport function ToggleGroup<R, SR>({\n  groupKey,\n  isExpanded,\n  tabIndex,\n  toggleGroup\n}: RenderGroupCellProps<R, SR>) {\n  function handleKeyDown({ key }: React.KeyboardEvent<HTMLSpanElement>) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n\n  return (\n    <span className={groupCellContentClassname} tabIndex={tabIndex} onKeyDown={handleKeyDown}>\n      {groupKey as string}\n      <svg viewBox=\"0 0 14 8\" width=\"14\" height=\"8\" className={caretClassname} aria-hidden>\n        <path d={d} />\n      </svg>\n    </span>\n  );\n}\n","import { memo } from 'react';\n\nimport { useRovingTabIndex } from './hooks';\nimport { getCellClassname, getCellStyle } from './utils';\nimport type { CalculatedColumn, GroupRow } from './types';\n\ninterface GroupCellProps<R, SR> {\n  id: string;\n  groupKey: unknown;\n  childRows: readonly R[];\n  toggleGroup: (expandedGroupId: unknown) => void;\n  isExpanded: boolean;\n  column: CalculatedColumn<R, SR>;\n  row: GroupRow<R>;\n  isCellSelected: boolean;\n  groupColumnIndex: number;\n  isGroupByColumn: boolean;\n}\n\nfunction GroupCell<R, SR>({\n  id,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  column,\n  row,\n  groupColumnIndex,\n  isGroupByColumn,\n  toggleGroup: toggleGroupWrapper\n}: GroupCellProps<R, SR>) {\n  const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  // Only make the cell clickable if the group level matches\n  const isLevelMatching = isGroupByColumn && groupColumnIndex === column.idx;\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      aria-selected={isCellSelected}\n      tabIndex={tabIndex}\n      key={column.key}\n      className={getCellClassname(column)}\n      style={{\n        ...getCellStyle(column),\n        cursor: isLevelMatching ? 'pointer' : 'default'\n      }}\n      onClick={isLevelMatching ? toggleGroup : undefined}\n      onFocus={onFocus}\n    >\n      {(!isGroupByColumn || isLevelMatching) &&\n        column.renderGroupCell?.({\n          groupKey,\n          childRows,\n          column,\n          row,\n          isExpanded,\n          tabIndex: childTabIndex,\n          toggleGroup\n        })}\n    </div>\n  );\n}\n\nexport default memo(GroupCell) as <R, SR>(props: GroupCellProps<R, SR>) => React.JSX.Element;\n","import { memo, useMemo } from 'react';\nimport { css } from '@linaria/core';\nimport clsx from 'clsx';\n\nimport { RowSelectionContext, type RowSelectionContextValue } from './hooks';\nimport { getRowStyle } from './utils';\nimport type { BaseRenderRowProps, GroupRow } from './types';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport GroupCell from './GroupCell';\nimport { cell, cellFrozen } from './style/cell';\nimport { rowClassname, rowSelectedClassname } from './style/row';\n\nconst groupRow = css`\n  @layer rdg.GroupedRow {\n    &:not([aria-selected='true']) {\n      background-color: var(--rdg-header-background-color);\n    }\n\n    > .${cell}:not(:last-child, .${cellFrozen}),\n    > :nth-last-child(n + 2 of .${cellFrozen}) {\n      border-inline-end: none;\n    }\n  }\n`;\n\nconst groupRowClassname = `rdg-group-row ${groupRow}`;\n\ninterface GroupRowRendererProps<R, SR> extends BaseRenderRowProps<R, SR> {\n  row: GroupRow<R>;\n  groupBy: readonly string[];\n  toggleGroup: (expandedGroupId: unknown) => void;\n}\n\nfunction GroupedRow<R, SR>({\n  className,\n  row,\n  rowIdx,\n  viewportColumns,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  gridRowStart,\n  groupBy,\n  toggleGroup,\n  isRowSelectionDisabled,\n  ...props\n}: GroupRowRendererProps<R, SR>) {\n  // Select is always the first column\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? row.level + 1 : row.level;\n\n  function handleSelectGroup() {\n    selectCell({ rowIdx, idx: -1 });\n  }\n\n  const selectionValue = useMemo(\n    (): RowSelectionContextValue => ({ isRowSelectionDisabled: false, isRowSelected }),\n    [isRowSelected]\n  );\n\n  return (\n    <RowSelectionContext value={selectionValue}>\n      <div\n        role=\"row\"\n        aria-level={row.level + 1} // aria-level is 1-based\n        aria-setsize={row.setSize}\n        aria-posinset={row.posInSet + 1} // aria-posinset is 1-based\n        aria-expanded={row.isExpanded}\n        className={clsx(\n          rowClassname,\n          groupRowClassname,\n          `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`,\n          selectedCellIdx === -1 && rowSelectedClassname,\n          className\n        )}\n        onClick={handleSelectGroup}\n        style={getRowStyle(gridRowStart)}\n        {...props}\n      >\n        {viewportColumns.map((column) => (\n          <GroupCell\n            key={column.key}\n            id={row.id}\n            groupKey={row.groupKey}\n            childRows={row.childRows}\n            isExpanded={row.isExpanded}\n            isCellSelected={selectedCellIdx === column.idx}\n            column={column}\n            row={row}\n            groupColumnIndex={idx}\n            toggleGroup={toggleGroup}\n            isGroupByColumn={groupBy.includes(column.key)}\n          />\n        ))}\n      </div>\n    </RowSelectionContext>\n  );\n}\n\nexport default memo(GroupedRow) as <R, SR>(\n  props: GroupRowRendererProps<R, SR>\n) => React.JSX.Element;\n","import { useCallback, useMemo } from 'react';\nimport type { Key } from 'react';\n\nimport { useLatestFunc } from './hooks';\nimport { assertIsValidKeyGetter, getLeftRightKey } from './utils';\nimport type {\n  CellClipboardEvent,\n  CellCopyEvent,\n  CellKeyboardEvent,\n  CellKeyDownArgs,\n  CellPasteEvent,\n  Column,\n  GroupRow,\n  Maybe,\n  Omit,\n  RenderRowProps,\n  RowHeightArgs,\n  RowsChangeData\n} from './types';\nimport { renderToggleGroup } from './cellRenderers';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport { DataGrid } from './DataGrid';\nimport type { DataGridProps } from './DataGrid';\nimport { useDefaultRenderers } from './DataGridDefaultRenderersContext';\nimport GroupedRow from './GroupRow';\nimport { defaultRenderRow } from './Row';\n\nexport interface TreeDataGridProps<R, SR = unknown, K extends Key = Key>\n  extends Omit<\n    DataGridProps<R, SR, K>,\n    'columns' | 'role' | 'aria-rowcount' | 'rowHeight' | 'onFill' | 'isRowSelectionDisabled'\n  > {\n  columns: readonly Column<NoInfer<R>, NoInfer<SR>>[];\n  rowHeight?: Maybe<number | ((args: RowHeightArgs<NoInfer<R>>) => number)>;\n  groupBy: readonly string[];\n  rowGrouper: (\n    rows: readonly NoInfer<R>[],\n    columnKey: string\n  ) => Record<string, readonly NoInfer<R>[]>;\n  expandedGroupIds: ReadonlySet<unknown>;\n  onExpandedGroupIdsChange: (expandedGroupIds: Set<unknown>) => void;\n  groupIdGetter?: Maybe<(groupKey: string, parentId?: string) => string>;\n}\n\ntype GroupByDictionary<TRow> = Record<\n  string,\n  {\n    readonly childRows: readonly TRow[];\n    readonly childGroups: readonly TRow[] | Readonly<GroupByDictionary<TRow>>;\n    readonly startRowIndex: number;\n  }\n>;\n\nexport function TreeDataGrid<R, SR = unknown, K extends Key = Key>({\n  columns: rawColumns,\n  rows: rawRows,\n  rowHeight: rawRowHeight,\n  rowKeyGetter: rawRowKeyGetter,\n  onCellKeyDown: rawOnCellKeyDown,\n  onCellCopy: rawOnCellCopy,\n  onCellPaste: rawOnCellPaste,\n  onRowsChange,\n  selectedRows: rawSelectedRows,\n  onSelectedRowsChange: rawOnSelectedRowsChange,\n  renderers,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  groupIdGetter: rawGroupIdGetter,\n  ...props\n}: TreeDataGridProps<R, SR, K>) {\n  const defaultRenderers = useDefaultRenderers<R, SR>();\n  const rawRenderRow = renderers?.renderRow ?? defaultRenderers?.renderRow ?? defaultRenderRow;\n  const headerAndTopSummaryRowsCount = 1 + (props.topSummaryRows?.length ?? 0);\n  const { leftKey, rightKey } = getLeftRightKey(props.direction);\n  const toggleGroupLatest = useLatestFunc(toggleGroup);\n  const groupIdGetter = rawGroupIdGetter ?? defaultGroupIdGetter;\n\n  const { columns, groupBy } = useMemo(() => {\n    const columns = [...rawColumns].sort(({ key: aKey }, { key: bKey }) => {\n      // Sort select column first:\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      // Sort grouped columns second, following the groupBy order:\n      if (rawGroupBy.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n        return -1;\n      }\n      if (rawGroupBy.includes(bKey)) return 1;\n\n      // Sort other columns last:\n      return 0;\n    });\n\n    const groupBy: string[] = [];\n    for (const [index, column] of columns.entries()) {\n      if (rawGroupBy.includes(column.key)) {\n        groupBy.push(column.key);\n        columns[index] = {\n          ...column,\n          frozen: true,\n          renderCell: () => null,\n          renderGroupCell: column.renderGroupCell ?? renderToggleGroup,\n          editable: false\n        };\n      }\n    }\n\n    return { columns, groupBy };\n  }, [rawColumns, rawGroupBy]);\n\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0) return [undefined, rawRows.length];\n\n    const groupRows = (\n      rows: readonly R[],\n      [groupByKey, ...remainingGroupByKeys]: readonly string[],\n      startRowIndex: number\n    ): [Readonly<GroupByDictionary<R>>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] =\n          remainingGroupByKeys.length === 0\n            ? [childRows, childRows.length]\n            : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, isGroupRow] = useMemo((): [\n    ReadonlyArray<R | GroupRow<R>>,\n    (row: R | GroupRow<R>) => row is GroupRow<R>\n  ] => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, isGroupRow];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n\n    const expandGroup = (\n      rows: GroupByDictionary<R> | readonly R[],\n      parentId: string | undefined,\n      level: number\n    ): void => {\n      if (isReadonlyArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        const id = groupIdGetter(groupKey, parentId);\n        const isExpanded = expandedGroupIds.has(id);\n        const { childRows, childGroups, startRowIndex } = rows[groupKey];\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, isGroupRow];\n\n    function isGroupRow(row: R | GroupRow<R>): row is GroupRow<R> {\n      return allGroupRows.has(row);\n    }\n  }, [expandedGroupIds, groupedRows, rawRows, groupIdGetter]);\n\n  const rowHeight = useMemo(() => {\n    if (typeof rawRowHeight === 'function') {\n      return (row: R | GroupRow<R>): number => {\n        if (isGroupRow(row)) {\n          return rawRowHeight({ type: 'GROUP', row });\n        }\n        return rawRowHeight({ type: 'ROW', row });\n      };\n    }\n\n    return rawRowHeight;\n  }, [isGroupRow, rawRowHeight]);\n\n  const getParentRowAndIndex = useCallback(\n    (row: R | GroupRow<R>) => {\n      const rowIdx = rows.indexOf(row);\n      for (let i = rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n        if (isGroupRow(parentRow) && (!isGroupRow(row) || row.parentId === parentRow.id)) {\n          return [parentRow, i] as const;\n        }\n      }\n\n      return undefined;\n    },\n    [isGroupRow, rows]\n  );\n\n  const rowKeyGetter = useCallback(\n    (row: R | GroupRow<R>) => {\n      if (isGroupRow(row)) {\n        return row.id;\n      }\n\n      if (typeof rawRowKeyGetter === 'function') {\n        return rawRowKeyGetter(row);\n      }\n\n      const parentRowAndIndex = getParentRowAndIndex(row);\n      if (parentRowAndIndex !== undefined) {\n        const { startRowIndex, childRows } = parentRowAndIndex[0];\n        const groupIndex = childRows.indexOf(row);\n        return startRowIndex + groupIndex + 1;\n      }\n\n      return rows.indexOf(row);\n    },\n    [getParentRowAndIndex, isGroupRow, rawRowKeyGetter, rows]\n  );\n\n  const selectedRows = useMemo((): Maybe<ReadonlySet<Key>> => {\n    if (rawSelectedRows == null) return null;\n\n    assertIsValidKeyGetter<R, K>(rawRowKeyGetter);\n\n    const selectedRows = new Set<Key>(rawSelectedRows);\n    for (const row of rows) {\n      if (isGroupRow(row)) {\n        // select parent row if all the children are selected\n        const isGroupRowSelected = row.childRows.every((cr) =>\n          rawSelectedRows.has(rawRowKeyGetter(cr))\n        );\n        if (isGroupRowSelected) {\n          selectedRows.add(row.id);\n        }\n      }\n    }\n\n    return selectedRows;\n  }, [isGroupRow, rawRowKeyGetter, rawSelectedRows, rows]);\n\n  function onSelectedRowsChange(newSelectedRows: Set<Key>) {\n    if (!rawOnSelectedRowsChange) return;\n\n    assertIsValidKeyGetter<R, K>(rawRowKeyGetter);\n\n    const newRawSelectedRows = new Set(rawSelectedRows);\n    for (const row of rows) {\n      const key = rowKeyGetter(row);\n      if (selectedRows?.has(key) && !newSelectedRows.has(key)) {\n        if (isGroupRow(row)) {\n          // select all children if the parent row is selected\n          for (const cr of row.childRows) {\n            newRawSelectedRows.delete(rawRowKeyGetter(cr));\n          }\n        } else {\n          newRawSelectedRows.delete(key as K);\n        }\n      } else if (!selectedRows?.has(key) && newSelectedRows.has(key)) {\n        if (isGroupRow(row)) {\n          // unselect all children if the parent row is unselected\n          for (const cr of row.childRows) {\n            newRawSelectedRows.add(rawRowKeyGetter(cr));\n          }\n        } else {\n          newRawSelectedRows.add(key as K);\n        }\n      }\n    }\n\n    rawOnSelectedRowsChange(newRawSelectedRows);\n  }\n\n  function handleKeyDown(args: CellKeyDownArgs<R, SR>, event: CellKeyboardEvent) {\n    rawOnCellKeyDown?.(args, event);\n    if (event.isGridDefaultPrevented()) return;\n\n    if (args.mode === 'EDIT') return;\n    const { column, rowIdx, selectCell } = args;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const idx = column?.idx ?? -1;\n    const row = rows[rowIdx];\n\n    if (!isGroupRow(row)) return;\n    if (\n      idx === -1 &&\n      // Collapse the current group row if it is focused and is in expanded state\n      ((event.key === leftKey && row.isExpanded) ||\n        // Expand the current group row if it is focused and is in collapsed state\n        (event.key === rightKey && !row.isExpanded))\n    ) {\n      // prevent scrolling\n      event.preventDefault();\n      event.preventGridDefault();\n      toggleGroup(row.id);\n    }\n\n    // If a group row is focused, and it is collapsed, move to the parent group row (if there is one).\n    if (idx === -1 && event.key === leftKey && !row.isExpanded && row.level !== 0) {\n      const parentRowAndIndex = getParentRowAndIndex(row);\n      if (parentRowAndIndex !== undefined) {\n        event.preventGridDefault();\n        selectCell({ idx, rowIdx: parentRowAndIndex[1] });\n      }\n    }\n  }\n\n  // Prevent copy/paste on group rows\n  function handleCellCopy(\n    { row, column }: CellCopyEvent<NoInfer<R>, NoInfer<SR>>,\n    event: CellClipboardEvent\n  ) {\n    if (!isGroupRow(row)) {\n      rawOnCellCopy?.({ row, column }, event);\n    }\n  }\n\n  function handleCellPaste(\n    { row, column }: CellPasteEvent<NoInfer<R>, NoInfer<SR>>,\n    event: CellClipboardEvent\n  ) {\n    return isGroupRow(row) ? row : rawOnCellPaste!({ row, column }, event);\n  }\n\n  function handleRowsChange(updatedRows: R[], { indexes, column }: RowsChangeData<R, SR>) {\n    if (!onRowsChange) return;\n    const updatedRawRows = [...rawRows];\n    const rawIndexes: number[] = [];\n    for (const index of indexes) {\n      const rawIndex = rawRows.indexOf(rows[index] as R);\n      updatedRawRows[rawIndex] = updatedRows[index];\n      rawIndexes.push(rawIndex);\n    }\n    onRowsChange(updatedRawRows, {\n      indexes: rawIndexes,\n      column\n    });\n  }\n\n  function toggleGroup(groupId: unknown) {\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n    if (newExpandedGroupIds.has(groupId)) {\n      newExpandedGroupIds.delete(groupId);\n    } else {\n      newExpandedGroupIds.add(groupId);\n    }\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function renderRow(\n    key: Key,\n    {\n      row,\n      rowClass,\n      onCellClick,\n      onCellDoubleClick,\n      onCellContextMenu,\n      onRowChange,\n      lastFrozenColumnIndex,\n      draggedOverCellIdx,\n      setDraggedOverRowIdx,\n      selectedCellEditor,\n      ...rowProps\n    }: RenderRowProps<R, SR>\n  ) {\n    if (isGroupRow(row)) {\n      const { startRowIndex } = row;\n      return (\n        <GroupedRow\n          key={key}\n          {...rowProps}\n          aria-rowindex={headerAndTopSummaryRowsCount + startRowIndex + 1}\n          row={row}\n          groupBy={groupBy}\n          toggleGroup={toggleGroupLatest}\n        />\n      );\n    }\n\n    let ariaRowIndex = rowProps['aria-rowindex'];\n    const parentRowAndIndex = getParentRowAndIndex(row);\n    if (parentRowAndIndex !== undefined) {\n      const { startRowIndex, childRows } = parentRowAndIndex[0];\n      const groupIndex = childRows.indexOf(row);\n      ariaRowIndex = startRowIndex + headerAndTopSummaryRowsCount + groupIndex + 2;\n    }\n\n    return rawRenderRow(key, {\n      ...rowProps,\n      'aria-rowindex': ariaRowIndex,\n      row,\n      rowClass,\n      onCellClick,\n      onCellDoubleClick,\n      onCellContextMenu,\n      onRowChange,\n      lastFrozenColumnIndex,\n      draggedOverCellIdx,\n      setDraggedOverRowIdx,\n      selectedCellEditor\n    });\n  }\n\n  return (\n    <DataGrid<R, SR>\n      {...props}\n      role=\"treegrid\"\n      aria-rowcount={\n        rowsCount + 1 + (props.topSummaryRows?.length ?? 0) + (props.bottomSummaryRows?.length ?? 0)\n      }\n      columns={columns}\n      rows={rows as R[]} // TODO: check types\n      rowHeight={rowHeight}\n      rowKeyGetter={rowKeyGetter}\n      onRowsChange={handleRowsChange}\n      selectedRows={selectedRows}\n      onSelectedRowsChange={onSelectedRowsChange}\n      onCellKeyDown={handleKeyDown}\n      onCellCopy={handleCellCopy}\n      onCellPaste={rawOnCellPaste ? handleCellPaste : undefined}\n      renderers={{\n        ...renderers,\n        renderRow\n      }}\n    />\n  );\n}\n\nfunction defaultGroupIdGetter(groupKey: string, parentId: string | undefined) {\n  return parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n}\n\nfunction isReadonlyArray(arr: unknown): arr is readonly unknown[] {\n  return Array.isArray(arr);\n}\n","import { useState } from 'react';\nimport { faker } from '@faker-js/faker';\nimport { createFileRoute } from '@tanstack/react-router';\nimport { css } from '@linaria/core';\n\nimport { SelectColumn, TreeDataGrid } from '../../src';\nimport type { Column } from '../../src';\nimport { useDirection } from '../directionContext';\n\nexport const Route = createFileRoute('/RowGrouping')({\n  component: RowGrouping\n});\n\nconst groupingClassname = css`\n  display: flex;\n  flex-direction: column;\n  block-size: 100%;\n  gap: 8px;\n\n  > .rdg {\n    flex: 1;\n  }\n`;\n\nconst optionsClassname = css`\n  display: flex;\n  gap: 8px;\n  text-transform: capitalize;\n`;\n\ninterface Row {\n  id: number;\n  country: string;\n  year: number;\n  sport: string;\n  athlete: string;\n  gold: number;\n  silver: number;\n  bronze: number;\n}\n\nconst sports = [\n  'Swimming',\n  'Gymnastics',\n  'Speed Skating',\n  'Cross Country Skiing',\n  'Short-Track Speed Skating',\n  'Diving',\n  'Cycling',\n  'Biathlon',\n  'Alpine Skiing',\n  'Ski Jumping',\n  'Nordic Combined',\n  'Athletics',\n  'Table Tennis',\n  'Tennis',\n  'Synchronized Swimming',\n  'Shooting',\n  'Rowing',\n  'Fencing',\n  'Equestrian',\n  'Canoeing',\n  'Bobsleigh',\n  'Badminton',\n  'Archery',\n  'Wrestling',\n  'Weightlifting',\n  'Waterpolo',\n  'Wrestling',\n  'Weightlifting'\n];\n\nconst columns: readonly Column<Row>[] = [\n  SelectColumn,\n  {\n    key: 'country',\n    name: 'Country'\n  },\n  {\n    key: 'year',\n    name: 'Year'\n  },\n  {\n    key: 'sport',\n    name: 'Sport'\n  },\n  {\n    key: 'athlete',\n    name: 'Athlete'\n  },\n  {\n    key: 'gold',\n    name: 'Gold',\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, { gold }) => prev + gold, 0);\n    }\n  },\n  {\n    key: 'silver',\n    name: 'Silver',\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, { silver }) => prev + silver, 0);\n    }\n  },\n  {\n    key: 'bronze',\n    name: 'Bronze',\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, { silver }) => prev + silver, 0);\n    }\n  },\n  {\n    key: 'total',\n    name: 'Total',\n    renderCell({ row }) {\n      return row.gold + row.silver + row.bronze;\n    },\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, row) => prev + row.gold + row.silver + row.bronze, 0);\n    }\n  }\n];\n\nfunction rowKeyGetter(row: Row) {\n  return row.id;\n}\n\nfunction createRows(): readonly Row[] {\n  const rows: Row[] = [];\n  for (let i = 1; i < 10000; i++) {\n    rows.push({\n      id: i,\n      year: 2015 + faker.number.int(3),\n      country: faker.location.country(),\n      sport: sports[faker.number.int(sports.length - 1)],\n      athlete: faker.person.fullName(),\n      gold: faker.number.int(5),\n      silver: faker.number.int(5),\n      bronze: faker.number.int(5)\n    });\n  }\n\n  return rows.sort((r1, r2) => r2.country.localeCompare(r1.country));\n}\n\nconst options = ['country', 'year', 'sport', 'athlete'] as const;\n\nfunction RowGrouping() {\n  const direction = useDirection();\n  const [rows] = useState(createRows);\n  const [selectedRows, setSelectedRows] = useState((): ReadonlySet<number> => new Set());\n  const [selectedOptions, setSelectedOptions] = useState<readonly string[]>([\n    options[0],\n    options[1]\n  ]);\n  const [expandedGroupIds, setExpandedGroupIds] = useState(\n    (): ReadonlySet<unknown> =>\n      new Set<unknown>(['United States of America', 'United States of America__2015'])\n  );\n\n  function toggleOption(option: string, enabled: boolean) {\n    const index = selectedOptions.indexOf(option);\n    if (enabled) {\n      if (index === -1) {\n        setSelectedOptions((options) => [...options, option]);\n      }\n    } else if (index !== -1) {\n      setSelectedOptions((options) => {\n        const newOptions = [...options];\n        newOptions.splice(index, 1);\n        return newOptions;\n      });\n    }\n    setExpandedGroupIds(new Set());\n  }\n\n  return (\n    <div className={groupingClassname}>\n      <b>Group by columns:</b>\n      <div className={optionsClassname}>\n        {options.map((option) => (\n          <label key={option}>\n            <input\n              type=\"checkbox\"\n              checked={selectedOptions.includes(option)}\n              onChange={(event) => toggleOption(option, event.target.checked)}\n            />{' '}\n            {option}\n          </label>\n        ))}\n      </div>\n\n      <TreeDataGrid\n        columns={columns}\n        rows={rows}\n        rowKeyGetter={rowKeyGetter}\n        selectedRows={selectedRows}\n        onSelectedRowsChange={setSelectedRows}\n        groupBy={selectedOptions}\n        rowGrouper={rowGrouper}\n        expandedGroupIds={expandedGroupIds}\n        onExpandedGroupIdsChange={setExpandedGroupIds}\n        defaultColumnOptions={{ resizable: true }}\n        direction={direction}\n      />\n    </div>\n  );\n}\n\nfunction rowGrouper(rows: readonly Row[], columnKey: string) {\n  // @ts-expect-error\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return Object.groupBy(rows, (r) => r[columnKey]) as Record<string, readonly R[]>;\n}\n"],"names":["groupCellContent","groupCellContentClassname","caret","caretClassname","renderToggleGroup","props","jsx","ToggleGroup","groupKey","isExpanded","tabIndex","toggleGroup","handleKeyDown","key","d","className","onKeyDown","children","viewBox","width","height","GroupCell","id","childRows","isCellSelected","column","row","groupColumnIndex","isGroupByColumn","toggleGroupWrapper","childTabIndex","onFocus","useRovingTabIndex","isLevelMatching","getCellClassname","getCellStyle","memo","groupRow","groupRowClassname","GroupedRow","rowIdx","viewportColumns","selectedCellIdx","isRowSelected","selectCell","gridRowStart","groupBy","isRowSelectionDisabled","idx","SELECT_COLUMN_KEY","level","handleSelectGroup","selectionValue","useMemo","RowSelectionContext","value","role","setSize","posInSet","clsx","rowClassname","rowSelectedClassname","onClick","style","getRowStyle","map","includes","TreeDataGrid","rawColumns","rawRows","rawRowHeight","rawRowKeyGetter","rawOnCellKeyDown","rawOnCellCopy","rawOnCellPaste","onRowsChange","rawSelectedRows","rawOnSelectedRowsChange","renderers","rawGroupBy","rowGrouper","expandedGroupIds","onExpandedGroupIdsChange","rawGroupIdGetter","defaultRenderers","useDefaultRenderers","rawRenderRow","defaultRenderRow","headerAndTopSummaryRowsCount","leftKey","rightKey","getLeftRightKey","toggleGroupLatest","useLatestFunc","groupIdGetter","defaultGroupIdGetter","columns","aKey","bKey","index","groupedRows","rowsCount","groupRows","rows","groupByKey","remainingGroupByKeys","startRowIndex","groupRowsCount","groups","childGroups","childRowsCount","isGroupRow","allGroupRows","flattenedRows","expandGroup","parentId","isReadonlyArray","keys","rowHeight","getParentRowAndIndex","useCallback","i","parentRow","rowKeyGetter","parentRowAndIndex","groupIndex","selectedRows","assertIsValidKeyGetter","cr","onSelectedRowsChange","newSelectedRows","newRawSelectedRows","args","event","handleCellCopy","handleCellPaste","handleRowsChange","updatedRows","indexes","updatedRawRows","rawIndexes","rawIndex","groupId","newExpandedGroupIds","renderRow","rowClass","onCellClick","onCellDoubleClick","onCellContextMenu","onRowChange","lastFrozenColumnIndex","draggedOverCellIdx","setDraggedOverRowIdx","selectedCellEditor","rowProps","ariaRowIndex","DataGrid","arr","groupingClassname","css","optionsClassname","sports","SelectColumn","name","renderGroupCell","reduce","prev","gold","silver","renderCell","bronze","createRows","push","year","faker","number","int","country","location","sport","length","athlete","person","fullName","sort","r1","r2","localeCompare","options","columnKey","Object","r","SplitComponent","direction","useDirection","useState","setSelectedRows","Set","selectedOptions","setSelectedOptions","setExpandedGroupIds","toggleOption","option","enabled","indexOf","newOptions","splice","jsxs","type","checked","onChange","target","defaultColumnOptions","resizable"],"mappings":"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"}