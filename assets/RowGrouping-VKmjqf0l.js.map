{"version":3,"file":"RowGrouping-VKmjqf0l.js","names":["props: RenderGroupCellProps<R, SR>","groupBy: string[]","rows: readonly R[]","startRowIndex: number","groups: GroupByDictionary<R>","flattenedRows: Array<R | GroupRow<R>>","rows: GroupByDictionary<R> | readonly R[]","parentId: string | undefined","level: number","groupRow: GroupRow<R>","row: R | GroupRow<R>","newSelectedRows: Set<Key>","args: CellKeyDownArgs<R, SR>","event: CellKeyboardEvent","event: CellClipboardEvent","updatedRows: R[]","rawIndexes: number[]","groupId: unknown","key: Key","groupKey: string","arr: unknown","useState","faker","css","SelectColumn","TreeDataGrid","Column","useDirection","Route","groupingClassname","optionsClassname","Row","id","country","year","sport","athlete","gold","silver","bronze","sports","columns","key","name","renderGroupCell","childRows","reduce","prev","renderCell","row","rowKeyGetter","createRows","rows","i","push","number","int","location","length","person","fullName","sort","r1","r2","localeCompare","options","const","rowGrouper","columnKey","Object","groupBy","r","Record","R","SplitComponent","RowGrouping","direction","selectedRows","setSelectedRows","ReadonlySet","Set","selectedOptions","setSelectedOptions","expandedGroupIds","setExpandedGroupIds","toggleOption","option","enabled","index","indexOf","toSpliced","map","includes","event","target","checked","resizable","component"],"sources":["../../src/cellRenderers/renderToggleGroup.tsx","../../src/GroupCell.tsx","../../src/GroupRow.tsx","../../src/TreeDataGrid.tsx","../../website/routes/RowGrouping.tsx?tsr-split=component"],"sourcesContent":["import { css } from '@linaria/core';\n\nimport type { RenderGroupCellProps } from '../types';\n\nconst groupCellContent = css`\n  @layer rdg.GroupCellContent {\n    outline: none;\n  }\n`;\n\nconst groupCellContentClassname = `rdg-group-cell-content ${groupCellContent}`;\n\nconst caret = css`\n  @layer rdg.GroupCellCaret {\n    margin-inline-start: 4px;\n    stroke: currentColor;\n    stroke-width: 1.5px;\n    fill: transparent;\n    vertical-align: middle;\n\n    > path {\n      transition: d 0.1s;\n    }\n  }\n`;\n\nconst caretClassname = `rdg-caret ${caret}`;\n\nexport function renderToggleGroup<R, SR>(props: RenderGroupCellProps<R, SR>) {\n  return <ToggleGroup {...props} />;\n}\n\nexport function ToggleGroup<R, SR>({\n  groupKey,\n  isExpanded,\n  tabIndex,\n  toggleGroup\n}: RenderGroupCellProps<R, SR>) {\n  function handleKeyDown({ key }: React.KeyboardEvent<HTMLSpanElement>) {\n    if (key === 'Enter') {\n      toggleGroup();\n    }\n  }\n\n  const d = isExpanded ? 'M1 1 L 7 7 L 13 1' : 'M1 7 L 7 1 L 13 7';\n\n  return (\n    <span className={groupCellContentClassname} tabIndex={tabIndex} onKeyDown={handleKeyDown}>\n      {groupKey as string}\n      <svg viewBox=\"0 0 14 8\" width=\"14\" height=\"8\" className={caretClassname} aria-hidden>\n        <path d={d} />\n      </svg>\n    </span>\n  );\n}\n","import { memo } from 'react';\n\nimport { useRovingTabIndex } from './hooks';\nimport { getCellClassname, getCellStyle } from './utils';\nimport type { CalculatedColumn, GroupRow } from './types';\n\ninterface GroupCellProps<R, SR> {\n  id: string;\n  groupKey: unknown;\n  childRows: readonly R[];\n  toggleGroup: (expandedGroupId: unknown) => void;\n  isExpanded: boolean;\n  column: CalculatedColumn<R, SR>;\n  row: GroupRow<R>;\n  isCellSelected: boolean;\n  groupColumnIndex: number;\n  isGroupByColumn: boolean;\n}\n\nfunction GroupCell<R, SR>({\n  id,\n  groupKey,\n  childRows,\n  isExpanded,\n  isCellSelected,\n  column,\n  row,\n  groupColumnIndex,\n  isGroupByColumn,\n  toggleGroup: toggleGroupWrapper\n}: GroupCellProps<R, SR>) {\n  const { tabIndex, childTabIndex, onFocus } = useRovingTabIndex(isCellSelected);\n\n  function toggleGroup() {\n    toggleGroupWrapper(id);\n  }\n\n  // Only make the cell clickable if the group level matches\n  const isLevelMatching = isGroupByColumn && groupColumnIndex === column.idx;\n\n  return (\n    <div\n      role=\"gridcell\"\n      aria-colindex={column.idx + 1}\n      aria-selected={isCellSelected}\n      tabIndex={tabIndex}\n      key={column.key}\n      className={getCellClassname(column)}\n      style={{\n        ...getCellStyle(column),\n        cursor: isLevelMatching ? 'pointer' : 'default'\n      }}\n      onMouseDown={(event) => {\n        // prevents clicking on the cell from stealing focus from focusSink\n        event.preventDefault();\n      }}\n      onClick={isLevelMatching ? toggleGroup : undefined}\n      onFocus={onFocus}\n    >\n      {(!isGroupByColumn || isLevelMatching) &&\n        column.renderGroupCell?.({\n          groupKey,\n          childRows,\n          column,\n          row,\n          isExpanded,\n          tabIndex: childTabIndex,\n          toggleGroup\n        })}\n    </div>\n  );\n}\n\nexport default memo(GroupCell) as <R, SR>(props: GroupCellProps<R, SR>) => React.JSX.Element;\n","import { memo, useMemo } from 'react';\nimport { css } from '@linaria/core';\nimport clsx from 'clsx';\n\nimport { RowSelectionContext, type RowSelectionContextValue } from './hooks';\nimport { getRowStyle } from './utils';\nimport type { BaseRenderRowProps, GroupRow } from './types';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport GroupCell from './GroupCell';\nimport { cell, cellFrozen } from './style/cell';\nimport { rowClassname, rowSelectedClassname } from './style/row';\n\nconst groupRow = css`\n  @layer rdg.GroupedRow {\n    &:not([aria-selected='true']) {\n      background-color: var(--rdg-header-background-color);\n    }\n\n    > .${cell}:not(:last-child, .${cellFrozen}),\n    > :nth-last-child(n + 2 of .${cellFrozen}) {\n      border-inline-end: none;\n    }\n  }\n`;\n\nconst groupRowClassname = `rdg-group-row ${groupRow}`;\n\ninterface GroupRowRendererProps<R, SR> extends BaseRenderRowProps<R, SR> {\n  row: GroupRow<R>;\n  groupBy: readonly string[];\n  toggleGroup: (expandedGroupId: unknown) => void;\n}\n\nfunction GroupedRow<R, SR>({\n  className,\n  row,\n  rowIdx,\n  viewportColumns,\n  selectedCellIdx,\n  isRowSelected,\n  selectCell,\n  gridRowStart,\n  groupBy,\n  toggleGroup,\n  isRowSelectionDisabled,\n  ...props\n}: GroupRowRendererProps<R, SR>) {\n  // Select is always the first column\n  const idx = viewportColumns[0].key === SELECT_COLUMN_KEY ? row.level + 1 : row.level;\n\n  function handleSelectGroup() {\n    selectCell({ rowIdx, idx: -1 }, { shouldFocusCell: true });\n  }\n\n  const selectionValue = useMemo(\n    (): RowSelectionContextValue => ({ isRowSelectionDisabled: false, isRowSelected }),\n    [isRowSelected]\n  );\n\n  return (\n    <RowSelectionContext value={selectionValue}>\n      <div\n        role=\"row\"\n        aria-level={row.level + 1} // aria-level is 1-based\n        aria-setsize={row.setSize}\n        aria-posinset={row.posInSet + 1} // aria-posinset is 1-based\n        aria-expanded={row.isExpanded}\n        className={clsx(\n          rowClassname,\n          groupRowClassname,\n          `rdg-row-${rowIdx % 2 === 0 ? 'even' : 'odd'}`,\n          selectedCellIdx === -1 && rowSelectedClassname,\n          className\n        )}\n        onMouseDown={handleSelectGroup}\n        style={getRowStyle(gridRowStart)}\n        {...props}\n      >\n        {viewportColumns.map((column) => (\n          <GroupCell\n            key={column.key}\n            id={row.id}\n            groupKey={row.groupKey}\n            childRows={row.childRows}\n            isExpanded={row.isExpanded}\n            isCellSelected={selectedCellIdx === column.idx}\n            column={column}\n            row={row}\n            groupColumnIndex={idx}\n            toggleGroup={toggleGroup}\n            isGroupByColumn={groupBy.includes(column.key)}\n          />\n        ))}\n      </div>\n    </RowSelectionContext>\n  );\n}\n\nexport default memo(GroupedRow) as <R, SR>(\n  props: GroupRowRendererProps<R, SR>\n) => React.JSX.Element;\n","import { useCallback, useMemo } from 'react';\nimport type { Key } from 'react';\n\nimport { useLatestFunc } from './hooks';\nimport { assertIsValidKeyGetter, getLeftRightKey } from './utils';\nimport type {\n  CellClipboardEvent,\n  CellCopyArgs,\n  CellKeyboardEvent,\n  CellKeyDownArgs,\n  CellPasteArgs,\n  Column,\n  GroupRow,\n  Maybe,\n  Omit,\n  RenderRowProps,\n  RowHeightArgs,\n  RowsChangeData\n} from './types';\nimport { renderToggleGroup } from './cellRenderers';\nimport { SELECT_COLUMN_KEY } from './Columns';\nimport { DataGrid } from './DataGrid';\nimport type { DataGridProps } from './DataGrid';\nimport { useDefaultRenderers } from './DataGridDefaultRenderersContext';\nimport GroupedRow from './GroupRow';\nimport { defaultRenderRow } from './Row';\n\nexport interface TreeDataGridProps<R, SR = unknown, K extends Key = Key>\n  extends Omit<\n    DataGridProps<R, SR, K>,\n    'columns' | 'role' | 'aria-rowcount' | 'rowHeight' | 'onFill' | 'isRowSelectionDisabled'\n  > {\n  columns: readonly Column<NoInfer<R>, NoInfer<SR>>[];\n  rowHeight?: Maybe<number | ((args: RowHeightArgs<NoInfer<R>>) => number)>;\n  groupBy: readonly string[];\n  rowGrouper: (\n    rows: readonly NoInfer<R>[],\n    columnKey: string\n  ) => Record<string, readonly NoInfer<R>[]>;\n  expandedGroupIds: ReadonlySet<unknown>;\n  onExpandedGroupIdsChange: (expandedGroupIds: Set<unknown>) => void;\n  groupIdGetter?: Maybe<(groupKey: string, parentId?: string) => string>;\n}\n\ntype GroupByDictionary<TRow> = Record<\n  string,\n  {\n    readonly childRows: readonly TRow[];\n    readonly childGroups: readonly TRow[] | Readonly<GroupByDictionary<TRow>>;\n    readonly startRowIndex: number;\n  }\n>;\n\nexport function TreeDataGrid<R, SR = unknown, K extends Key = Key>({\n  columns: rawColumns,\n  rows: rawRows,\n  rowHeight: rawRowHeight,\n  rowKeyGetter: rawRowKeyGetter,\n  onCellKeyDown: rawOnCellKeyDown,\n  onCellCopy: rawOnCellCopy,\n  onCellPaste: rawOnCellPaste,\n  onRowsChange,\n  selectedRows: rawSelectedRows,\n  onSelectedRowsChange: rawOnSelectedRowsChange,\n  renderers,\n  groupBy: rawGroupBy,\n  rowGrouper,\n  expandedGroupIds,\n  onExpandedGroupIdsChange,\n  groupIdGetter: rawGroupIdGetter,\n  ...props\n}: TreeDataGridProps<R, SR, K>) {\n  const defaultRenderers = useDefaultRenderers<R, SR>();\n  const rawRenderRow = renderers?.renderRow ?? defaultRenderers?.renderRow ?? defaultRenderRow;\n  const headerAndTopSummaryRowsCount = 1 + (props.topSummaryRows?.length ?? 0);\n  const { leftKey, rightKey } = getLeftRightKey(props.direction);\n  const toggleGroupLatest = useLatestFunc(toggleGroup);\n  const groupIdGetter = rawGroupIdGetter ?? defaultGroupIdGetter;\n\n  const { columns, groupBy } = useMemo(() => {\n    const columns = rawColumns.toSorted(({ key: aKey }, { key: bKey }) => {\n      // Sort select column first:\n      if (aKey === SELECT_COLUMN_KEY) return -1;\n      if (bKey === SELECT_COLUMN_KEY) return 1;\n\n      // Sort grouped columns second, following the groupBy order:\n      if (rawGroupBy.includes(aKey)) {\n        if (rawGroupBy.includes(bKey)) {\n          return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n        }\n        return -1;\n      }\n      if (rawGroupBy.includes(bKey)) return 1;\n\n      // Sort other columns last:\n      return 0;\n    });\n\n    const groupBy: string[] = [];\n    for (const [index, column] of columns.entries()) {\n      if (rawGroupBy.includes(column.key)) {\n        groupBy.push(column.key);\n        columns[index] = {\n          ...column,\n          frozen: true,\n          renderCell: () => null,\n          renderGroupCell: column.renderGroupCell ?? renderToggleGroup,\n          editable: false\n        };\n      }\n    }\n\n    return { columns, groupBy };\n  }, [rawColumns, rawGroupBy]);\n\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0) return [undefined, rawRows.length];\n\n    const groupRows = (\n      rows: readonly R[],\n      [groupByKey, ...remainingGroupByKeys]: readonly string[],\n      startRowIndex: number\n    ): [Readonly<GroupByDictionary<R>>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] =\n          remainingGroupByKeys.length === 0\n            ? [childRows, childRows.length]\n            : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, isGroupRow] = useMemo((): [\n    ReadonlyArray<R | GroupRow<R>>,\n    (row: R | GroupRow<R>) => row is GroupRow<R>\n  ] => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, isGroupRow];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n\n    const expandGroup = (\n      rows: GroupByDictionary<R> | readonly R[],\n      parentId: string | undefined,\n      level: number\n    ): void => {\n      if (isReadonlyArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        const id = groupIdGetter(groupKey, parentId);\n        const isExpanded = expandedGroupIds.has(id);\n        const { childRows, childGroups, startRowIndex } = rows[groupKey];\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, isGroupRow];\n\n    function isGroupRow(row: R | GroupRow<R>): row is GroupRow<R> {\n      return allGroupRows.has(row);\n    }\n  }, [expandedGroupIds, groupedRows, rawRows, groupIdGetter]);\n\n  const rowHeight = useMemo(() => {\n    if (typeof rawRowHeight === 'function') {\n      return (row: R | GroupRow<R>): number => {\n        if (isGroupRow(row)) {\n          return rawRowHeight({ type: 'GROUP', row });\n        }\n        return rawRowHeight({ type: 'ROW', row });\n      };\n    }\n\n    return rawRowHeight;\n  }, [isGroupRow, rawRowHeight]);\n\n  const getParentRowAndIndex = useCallback(\n    (row: R | GroupRow<R>) => {\n      const rowIdx = rows.indexOf(row);\n      for (let i = rowIdx - 1; i >= 0; i--) {\n        const parentRow = rows[i];\n        if (isGroupRow(parentRow) && (!isGroupRow(row) || row.parentId === parentRow.id)) {\n          return [parentRow, i] as const;\n        }\n      }\n\n      return undefined;\n    },\n    [isGroupRow, rows]\n  );\n\n  const rowKeyGetter = useCallback(\n    (row: R | GroupRow<R>) => {\n      if (isGroupRow(row)) {\n        return row.id;\n      }\n\n      if (typeof rawRowKeyGetter === 'function') {\n        return rawRowKeyGetter(row);\n      }\n\n      const parentRowAndIndex = getParentRowAndIndex(row);\n      if (parentRowAndIndex !== undefined) {\n        const { startRowIndex, childRows } = parentRowAndIndex[0];\n        const groupIndex = childRows.indexOf(row);\n        return startRowIndex + groupIndex + 1;\n      }\n\n      return rows.indexOf(row);\n    },\n    [getParentRowAndIndex, isGroupRow, rawRowKeyGetter, rows]\n  );\n\n  const selectedRows = useMemo((): Maybe<ReadonlySet<Key>> => {\n    if (rawSelectedRows == null) return null;\n\n    assertIsValidKeyGetter<R, K>(rawRowKeyGetter);\n\n    const selectedRows = new Set<Key>(rawSelectedRows);\n    for (const row of rows) {\n      if (isGroupRow(row)) {\n        // select parent row if all the children are selected\n        const isGroupRowSelected = row.childRows.every((cr) =>\n          rawSelectedRows.has(rawRowKeyGetter(cr))\n        );\n        if (isGroupRowSelected) {\n          selectedRows.add(row.id);\n        }\n      }\n    }\n\n    return selectedRows;\n  }, [isGroupRow, rawRowKeyGetter, rawSelectedRows, rows]);\n\n  function onSelectedRowsChange(newSelectedRows: Set<Key>) {\n    if (!rawOnSelectedRowsChange) return;\n\n    assertIsValidKeyGetter<R, K>(rawRowKeyGetter);\n\n    const newRawSelectedRows = new Set(rawSelectedRows);\n    for (const row of rows) {\n      const key = rowKeyGetter(row);\n      if (selectedRows?.has(key) && !newSelectedRows.has(key)) {\n        if (isGroupRow(row)) {\n          // select all children if the parent row is selected\n          for (const cr of row.childRows) {\n            newRawSelectedRows.delete(rawRowKeyGetter(cr));\n          }\n        } else {\n          newRawSelectedRows.delete(key as K);\n        }\n      } else if (!selectedRows?.has(key) && newSelectedRows.has(key)) {\n        if (isGroupRow(row)) {\n          // unselect all children if the parent row is unselected\n          for (const cr of row.childRows) {\n            newRawSelectedRows.add(rawRowKeyGetter(cr));\n          }\n        } else {\n          newRawSelectedRows.add(key as K);\n        }\n      }\n    }\n\n    rawOnSelectedRowsChange(newRawSelectedRows);\n  }\n\n  function handleKeyDown(args: CellKeyDownArgs<R, SR>, event: CellKeyboardEvent) {\n    rawOnCellKeyDown?.(args, event);\n    if (event.isGridDefaultPrevented()) return;\n\n    if (args.mode === 'EDIT') return;\n    const { column, rowIdx, selectCell } = args;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const idx = column?.idx ?? -1;\n    const row = rows[rowIdx];\n\n    if (!isGroupRow(row)) return;\n    if (\n      idx === -1 &&\n      // Collapse the current group row if it is focused and is in expanded state\n      ((event.key === leftKey && row.isExpanded) ||\n        // Expand the current group row if it is focused and is in collapsed state\n        (event.key === rightKey && !row.isExpanded))\n    ) {\n      // prevent scrolling\n      event.preventDefault();\n      event.preventGridDefault();\n      toggleGroup(row.id);\n    }\n\n    // If a group row is focused, and it is collapsed, move to the parent group row (if there is one).\n    if (idx === -1 && event.key === leftKey && !row.isExpanded && row.level !== 0) {\n      const parentRowAndIndex = getParentRowAndIndex(row);\n      if (parentRowAndIndex !== undefined) {\n        event.preventGridDefault();\n        selectCell({ idx, rowIdx: parentRowAndIndex[1] });\n      }\n    }\n  }\n\n  // Prevent copy/paste on group rows\n  function handleCellCopy(\n    { row, column }: CellCopyArgs<NoInfer<R>, NoInfer<SR>>,\n    event: CellClipboardEvent\n  ) {\n    if (!isGroupRow(row)) {\n      rawOnCellCopy?.({ row, column }, event);\n    }\n  }\n\n  function handleCellPaste(\n    { row, column }: CellPasteArgs<NoInfer<R>, NoInfer<SR>>,\n    event: CellClipboardEvent\n  ) {\n    return isGroupRow(row) ? row : rawOnCellPaste!({ row, column }, event);\n  }\n\n  function handleRowsChange(updatedRows: R[], { indexes, column }: RowsChangeData<R, SR>) {\n    if (!onRowsChange) return;\n    const updatedRawRows = [...rawRows];\n    const rawIndexes: number[] = [];\n    for (const index of indexes) {\n      const rawIndex = rawRows.indexOf(rows[index] as R);\n      updatedRawRows[rawIndex] = updatedRows[index];\n      rawIndexes.push(rawIndex);\n    }\n    onRowsChange(updatedRawRows, {\n      indexes: rawIndexes,\n      column\n    });\n  }\n\n  function toggleGroup(groupId: unknown) {\n    const newExpandedGroupIds = new Set(expandedGroupIds);\n    if (newExpandedGroupIds.has(groupId)) {\n      newExpandedGroupIds.delete(groupId);\n    } else {\n      newExpandedGroupIds.add(groupId);\n    }\n    onExpandedGroupIdsChange(newExpandedGroupIds);\n  }\n\n  function renderRow(\n    key: Key,\n    {\n      row,\n      rowClass,\n      onCellMouseDown,\n      onCellClick,\n      onCellDoubleClick,\n      onCellContextMenu,\n      onRowChange,\n      lastFrozenColumnIndex,\n      draggedOverCellIdx,\n      selectedCellEditor,\n      ...rowProps\n    }: RenderRowProps<R, SR>\n  ) {\n    if (isGroupRow(row)) {\n      const { startRowIndex } = row;\n      return (\n        <GroupedRow\n          key={key}\n          {...rowProps}\n          aria-rowindex={headerAndTopSummaryRowsCount + startRowIndex + 1}\n          row={row}\n          groupBy={groupBy}\n          toggleGroup={toggleGroupLatest}\n        />\n      );\n    }\n\n    let ariaRowIndex = rowProps['aria-rowindex'];\n    const parentRowAndIndex = getParentRowAndIndex(row);\n    if (parentRowAndIndex !== undefined) {\n      const { startRowIndex, childRows } = parentRowAndIndex[0];\n      const groupIndex = childRows.indexOf(row);\n      ariaRowIndex = startRowIndex + headerAndTopSummaryRowsCount + groupIndex + 2;\n    }\n\n    return rawRenderRow(key, {\n      ...rowProps,\n      'aria-rowindex': ariaRowIndex,\n      row,\n      rowClass,\n      onCellMouseDown,\n      onCellClick,\n      onCellDoubleClick,\n      onCellContextMenu,\n      onRowChange,\n      lastFrozenColumnIndex,\n      draggedOverCellIdx,\n      selectedCellEditor\n    });\n  }\n\n  return (\n    <DataGrid<R, SR>\n      {...props}\n      role=\"treegrid\"\n      aria-rowcount={\n        rowsCount + 1 + (props.topSummaryRows?.length ?? 0) + (props.bottomSummaryRows?.length ?? 0)\n      }\n      columns={columns}\n      rows={rows as R[]} // TODO: check types\n      rowHeight={rowHeight}\n      rowKeyGetter={rowKeyGetter}\n      onRowsChange={handleRowsChange}\n      selectedRows={selectedRows}\n      onSelectedRowsChange={onSelectedRowsChange}\n      onCellKeyDown={handleKeyDown}\n      onCellCopy={handleCellCopy}\n      onCellPaste={rawOnCellPaste ? handleCellPaste : undefined}\n      renderers={{\n        ...renderers,\n        renderRow\n      }}\n    />\n  );\n}\n\nfunction defaultGroupIdGetter(groupKey: string, parentId: string | undefined) {\n  return parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n}\n\nfunction isReadonlyArray(arr: unknown): arr is readonly unknown[] {\n  return Array.isArray(arr);\n}\n","import { useState } from 'react';\nimport { faker } from '@faker-js/faker';\nimport { css } from '@linaria/core';\n\nimport { SelectColumn, TreeDataGrid } from '../../src';\nimport type { Column } from '../../src';\nimport { useDirection } from '../directionContext';\n\nexport const Route = createFileRoute({\n  component: RowGrouping\n});\n\nconst groupingClassname = css`\n  display: flex;\n  flex-direction: column;\n  block-size: 100%;\n  gap: 8px;\n\n  > .rdg {\n    flex: 1;\n  }\n`;\n\nconst optionsClassname = css`\n  display: flex;\n  gap: 8px;\n  text-transform: capitalize;\n`;\n\ninterface Row {\n  id: number;\n  country: string;\n  year: number;\n  sport: string;\n  athlete: string;\n  gold: number;\n  silver: number;\n  bronze: number;\n}\n\nconst sports = [\n  'Swimming',\n  'Gymnastics',\n  'Speed Skating',\n  'Cross Country Skiing',\n  'Short-Track Speed Skating',\n  'Diving',\n  'Cycling',\n  'Biathlon',\n  'Alpine Skiing',\n  'Ski Jumping',\n  'Nordic Combined',\n  'Athletics',\n  'Table Tennis',\n  'Tennis',\n  'Synchronized Swimming',\n  'Shooting',\n  'Rowing',\n  'Fencing',\n  'Equestrian',\n  'Canoeing',\n  'Bobsleigh',\n  'Badminton',\n  'Archery',\n  'Wrestling',\n  'Weightlifting',\n  'Waterpolo',\n  'Wrestling',\n  'Weightlifting'\n];\n\nconst columns: readonly Column<Row>[] = [\n  SelectColumn,\n  {\n    key: 'country',\n    name: 'Country'\n  },\n  {\n    key: 'year',\n    name: 'Year'\n  },\n  {\n    key: 'sport',\n    name: 'Sport'\n  },\n  {\n    key: 'athlete',\n    name: 'Athlete'\n  },\n  {\n    key: 'gold',\n    name: 'Gold',\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, { gold }) => prev + gold, 0);\n    }\n  },\n  {\n    key: 'silver',\n    name: 'Silver',\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, { silver }) => prev + silver, 0);\n    }\n  },\n  {\n    key: 'bronze',\n    name: 'Bronze',\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, { silver }) => prev + silver, 0);\n    }\n  },\n  {\n    key: 'total',\n    name: 'Total',\n    renderCell({ row }) {\n      return row.gold + row.silver + row.bronze;\n    },\n    renderGroupCell({ childRows }) {\n      return childRows.reduce((prev, row) => prev + row.gold + row.silver + row.bronze, 0);\n    }\n  }\n];\n\nfunction rowKeyGetter(row: Row) {\n  return row.id;\n}\n\nfunction createRows(): readonly Row[] {\n  const rows: Row[] = [];\n  for (let i = 1; i < 10000; i++) {\n    rows.push({\n      id: i,\n      year: 2015 + faker.number.int(3),\n      country: faker.location.country(),\n      sport: sports[faker.number.int(sports.length - 1)],\n      athlete: faker.person.fullName(),\n      gold: faker.number.int(5),\n      silver: faker.number.int(5),\n      bronze: faker.number.int(5)\n    });\n  }\n\n  return rows.sort((r1, r2) => r2.country.localeCompare(r1.country));\n}\n\nconst options = ['country', 'year', 'sport', 'athlete'] as const;\n\nfunction RowGrouping() {\n  const direction = useDirection();\n  const [rows] = useState(createRows);\n  const [selectedRows, setSelectedRows] = useState((): ReadonlySet<number> => new Set());\n  const [selectedOptions, setSelectedOptions] = useState<readonly string[]>([\n    options[0],\n    options[1]\n  ]);\n  const [expandedGroupIds, setExpandedGroupIds] = useState(\n    (): ReadonlySet<unknown> =>\n      new Set<unknown>(['United States of America', 'United States of America__2015'])\n  );\n\n  function toggleOption(option: string, enabled: boolean) {\n    const index = selectedOptions.indexOf(option);\n    if (enabled) {\n      if (index === -1) {\n        setSelectedOptions((options) => [...options, option]);\n      }\n    } else if (index !== -1) {\n      setSelectedOptions((options) => {\n        return options.toSpliced(index, 1);\n      });\n    }\n    setExpandedGroupIds(new Set());\n  }\n\n  return (\n    <div className={groupingClassname}>\n      <b>Group by columns:</b>\n      <div className={optionsClassname}>\n        {options.map((option) => (\n          <label key={option}>\n            <input\n              type=\"checkbox\"\n              checked={selectedOptions.includes(option)}\n              onChange={(event) => toggleOption(option, event.target.checked)}\n            />{' '}\n            {option}\n          </label>\n        ))}\n      </div>\n\n      <TreeDataGrid\n        aria-label=\"Row Grouping Example\"\n        columns={columns}\n        rows={rows}\n        rowKeyGetter={rowKeyGetter}\n        selectedRows={selectedRows}\n        onSelectedRowsChange={setSelectedRows}\n        groupBy={selectedOptions}\n        rowGrouper={rowGrouper}\n        expandedGroupIds={expandedGroupIds}\n        onExpandedGroupIdsChange={setExpandedGroupIds}\n        defaultColumnOptions={{ resizable: true }}\n        direction={direction}\n      />\n    </div>\n  );\n}\n\nfunction rowGrouper(rows: readonly Row[], columnKey: string) {\n  // @ts-expect-error\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return Object.groupBy(rows, (r) => r[columnKey]) as Record<string, readonly R[]>;\n}\n"],"mappings":"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"}